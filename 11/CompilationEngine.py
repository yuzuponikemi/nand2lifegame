# -*- coding: utf-8 -*-
"""
Created on Mon Mar 29 18:34:59 2021

CompilationEngine.py

Effects the actual compilation output. Gets its input from a JackTokenizer and emits
its parsed structure into an output file/stream. The output is generated by a series of compilexxx ( )
routines, one for every syntactic element xxx of the Jack grammar. The contract between these routines is
that each compilexxx ( ) routine should read the syntactic construct xxx from the input, advance ( ) the
tokenizer exactly beyond xxx, and output the parsing of xxx. Thus, compilexxx ( ) may only be called if
indeed xxx is the next syntactic element of the input.
In the first version of the compiler, described in chapter 10, this module emits a structured printout of
the code, wrapped in XML tags. In the final version of the compiler, described in chapter 11, this module
generates executable VM code. In both cases, the parsing logic and module API are exactly the same.


@author: IKM1YH
"""
import VMWriter
import SymbolTable

class CompilationEngine:
    def __init__(self,tokenizerinstance, output):
        '''Opens the outputfile.asm and gets ready to write into it.'''
        self.tn = tokenizerinstance
        self.filename=output
        self.ind = ''
        self.f = open(self.filename, 'w')
        self.tbl = SymbolTable.SymbolTable()
        self.vmw = VMWriter.VMWriter(self.f,self.tbl)
        self.ifcounter = -1
        self.whilecounter = -1
        
    

    
    def cenginekey(self):
        #print(self.tn.tokenType())
        #self.typedic = {KEYWORD, SYMBOL, IDENTIFIER, INT_CONST, STRING_CONST}
        key = '//end with -->'+self.tn.currenttkn
        compiling = True
        if self.tn.currenttkn == 'class':self.compileclass()
        elif self.tn.currenttkn == 'var':self.compileVarDec()
        elif self.tn.currenttkn == 'do':self.compileDo()
        elif self.tn.currenttkn == 'let':self.compileLet()
        elif self.tn.currenttkn == 'while':self.compileWhile()
        elif self.tn.currenttkn == 'return':self.compileReturn()
        elif self.tn.currenttkn == 'if':self.compileIf()
        elif self.tn.currenttkn in ['method', 'constructor', 'function']:self.compileSubroutine()
        #if self.tn.currenttkn in ['int', 'char','boolean',classname]:self.compiletype()
        elif self.tn.currenttkn in ['field','static']:self.compileclassVarDec()
        #print(self.tn.keyWord())
        else : 
            key = self.tn.keyWord()
            compiling = False
        return key, compiling

        
    def cengine(self,mode):
        #print(self.tn.tokenType())
        #self.typedic = {KEYWORD, SYMBOL, IDENTIFIER, INT_CONST, STRING_CONST}
        if self.tn.tokenType() == 'KEYWORD':
            if mode:
                return self.cenginekey()
            else:
                return self.tn.keyWord(), False
        elif self.tn.tokenType() == 'SYMBOL':
            #self.ce.compilesymbol()
            return self.tn.symbol(), False
        elif self.tn.tokenType() == 'IDENTIFIER':
            #self.ce.compileidentifier()
            return self.tn.identifier(self.tbl), False
        elif self.tn.tokenType() == 'INT_CONST':
            #self.ce.compileintVal()
            return self.tn.intVal(), False
        elif self.tn.tokenType() == 'STRING_CONST':
            #self.ce.compilestringVal()
            tagged, string = self.tn.stringVal()
            self.writeString(string)
            return tagged, False
        else:
            return 'notype', False
        
    def writeString(self,string):
        self.vmw.writePush('constant',len(string))
        self.vmw.writeCall('String.new', 1)
        for char in string:
            self.vmw.writePush('constant',ord(char))
            self.vmw.writeCall('String.appendChar', 2)
        
    def writetkn(self,mode):
        #print(self.ind + self.cengine(mode))
        tagged, compiling = self.cengine(mode)
        #if not compiling:
            ##self.f.write(self.ind + tagged)
        return None


    def compileclass(self):
        '''
        '''
        ##self.f.write(self.ind + '<class>' +'\n')
        self.ind += '  '
        self.writetkn(False)#write'class'
        self.tn.advance()
        self.classname = self.tn.currenttkn
        self.tbl.define(self.tn.currenttkn, 'class'  , 'pointer')
        while(True):
            if self.tn.currenttkn == '}':break            
            self.writetkn(True)
            self.tn.advance()
            
        self.writetkn(True)#}
        #self.tn.advance()
        self.ind = self.ind[:-2]
        ##self.f.write(self.ind + '</class>' +'\n')
        print(self.tbl.ctbl)
        return None

    def compileclassVarDec(self):
        '''
        '''
        #self.f.write(self.ind + '<classVarDec>' +'\n')
        self.add2tbl()
        self.ind += '  '
        self.writetkn(False)#write['field','static']
        while(True):
            if self.tn.currenttkn == ';':break
            self.tn.advance()
            self.writetkn(False)
            
        #self.tn.advance()
        
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</classVarDec>' +'\n')
        return None
    
    
    
    def add2tbl(self):
        '''only called when currenttkn is fiels/static/var/
            format --- name : [type, kind, #]
        define(self, name, types, kind):
        if kind == 'static':
            self.ctbl[name] = [types, kind, self.staticn]
                           '''
        c = self.tn.counter-1
        csymb = c + 2
        while True:
            self.tbl.define(self.tn.tkns[csymb], self.tn.tkns[c+1], self.tn.tkns[c]  )
            if self.tn.tkns[csymb+1] == ';':break
            csymb = csymb + 2
        
    def addarg2tbl(self):
        '''only called when currenttkn indicates argument(in parameterlist)'''
        nArgs = 0
        if self.tn.currenttkn == 'method':
            self.tbl.define('objextbase', self.classname,  'arg')
            nArgs +=1
        c = self.tn.counter+3 # ) or arg
        if self.tn.tkns[c] == ')':
            return nArgs
        else:
            self.tbl.define(self.tn.tkns[c+1], self.tn.tkns[c],  'arg')
            nArgs +=1
            while True:# in case more than 2 variable declared
                if self.tn.tkns[c+2] == ')':break
                c = c + 3
                self.tbl.define(self.tn.tkns[c+1], self.tn.tkns[c],  'arg')
                nArgs +=1
            return nArgs
            
    
    
    def compileSubroutine(self):
        '''ex---- constructor Square new(int Ax, int Ay, int Asize)
        '''
        self.tbl.startSubroutine()
        #self.f.write(self.ind + '<subroutineDec>' +'\n')
        self.ind += '  '
        
        #Adds subroutine to classtable
        nArgs = self.addarg2tbl()
        self.currentsubroutine = self.classname + '.' + self.tn.tkns[self.tn.counter+1]
        self.tbl.define(self.currentsubroutine, self.tn.tkns[self.tn.counter], self.tn.currenttkn ,nArgs )
        #                         new        :    [Square, constructor, nArgs]
        
        
        
        #self.writetkn(False)
        while(True):
            if self.tn.currenttkn == '(':break
            self.writetkn(False)
            self.tn.advance()
        self.writetkn(False)#(
        self.tn.advance()
        
        #if not self.tn.currenttkn == ')':self.addarg2tbl()
        self.compileParameterList()
        self.writetkn(False)
        self.tn.advance()
        self.compilesubroutineBody()
        
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</subroutineDec>' +'\n')
        return None
    
    def compileParameterList(self):
        '''
        '''
        #self.f.write(self.ind + '<parameterList>' +'\n')
        
        self.ind += '  '
        #self.writetkn(False)
        while(True):
            if self.tn.currenttkn == ')':break
            self.writetkn(False)
            self.tn.advance()
        
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</parameterList>' +'\n')
        # self.writetkn(False)
        # self.tn.advance()
        return None
    
    def compilesubroutineBody(self):
        '''
        '''
        #self.f.write(self.ind + '<subroutineBody>' +'\n')
        self.ind += '  '
        self.writetkn(False)
        self.tn.advance()
        while(True):
            
            if self.tn.currenttkn == 'var':
                self.compileVarDec()
            elif self.tn.currenttkn == '}':
                self.writetkn(False)
                break
            else:
                self.vmw.writeFunction(self.currentsubroutine,self.tbl.varCount('var'))
                self.compileStatements()
    
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</subroutineBody>' +'\n')
        return None
    
    def compileVarDec(self):
        '''
        '''
        #self.f.write(self.ind + '<VarDec>' +'\n')
        self.add2tbl()#var
        self.ind += '  '
        self.writetkn(False)#var
        while(True):
            self.tn.advance()
            self.writetkn(False)
            if self.tn.currenttkn == ';':break
        self.tn.advance()
        
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</VarDec>' +'\n')
        return None
    
    def compileDo(self):
        '''
        '''
        #self.f.write(self.ind + '<doStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#do
        while(True):
            self.tn.advance()
            self.compileTerm(True)
            if self.tn.currenttkn == ';':break
        self.vmw.writePop('temp',0)
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</doStatement>' +'\n')
        return None
    
    def compileLet(self):
        ''' let c = Array.new(1);
            let a[3] = 2;
            let k = (3+y);
        '''
        #self.f.write(self.ind + '<letStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#let
        self.tn.advance()
        var = self.tn.currenttkn
        if self.tn.tkns[self.tn.counter] == '[':#array[exp1]=exp2
            self.writePushExp(self.tn.currenttkn) # push array base address
            self.writetkn(False)#var 
            self.tn.advance()
            self.writetkn(False)#[
            self.tn.advance()
            self.compileExpression()#exp1
            self.vmw.writeArithmetic('+')
            self.writetkn(False)# ]
            self.tn.advance()
            self.writetkn(False)#=
            self.tn.advance()
            self.compileExpression()#exp2
            self.vmw.writePop('temp',0)#
            self.writetkn(False)#;
            self.vmw.writePop('pointer',1)#
            self.vmw.writePush('temp',0)#
            self.vmw.writePop('that',0)
            
        else:#normal var
            self.writetkn(False)#varName or ]
            self.tn.advance()
    
            self.writetkn(False)#=
            self.tn.advance()
            self.compileExpression()
            self.writetkn(False)#;
            
            if var in self.tbl.mtbl:
                    self.vmw.writePop(self.tbl.mtbl[var][1], self.tbl.mtbl[var][2])
            else:
                if var in self.tbl.ctbl:
                    self.vmw.writePop(self.tbl.ctbl[var][1], self.tbl.ctbl[var][2])
            
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</letStatement>' +'\n')
        return None
    
    def compileWhile(self):
        '''
        '''
        self.whilecounter += 1
        whilelabel1, whilelabel2 = ('LOOP_START'+str(self.whilecounter)),('LOOP_END'+str(self.whilecounter))
        #self.f.write(self.ind + '<whileStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#while
        self.tn.advance()
        self.writetkn(False)#(
        self.tn.advance()
        self.vmw.writeLabel(whilelabel1) #label whilelabel1
        self.compileExpression()#cond
        self.vmw.writeArithmetic('~',True) # denial
        self.vmw.writeIf(whilelabel2)# if-goto whilelabel2

        self.writetkn(False)#)
        self.tn.advance()
        self.writetkn(False)#{
        self.tn.advance()
        self.compileStatements() #s1
        self.writetkn(False)#}
        self.vmw.writeGoto(whilelabel1) # goto whilelabel1
        self.vmw.writeLabel(whilelabel2) # label whilelabel2
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</whileStatement>' +'\n')
        return None
    
    def compileReturn(self):
        '''
        '''
        #self.f.write(self.ind + '<returnStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#return
        self.tn.advance()
        while(True):
            if self.tn.currenttkn == ';':break
            self.compileExpression()
            if self.tn.currenttkn == ';':break
            self.tn.advance()
        
        self.vmw.Return(self.currentsubroutine)
        
        self.writetkn(False)#;
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</returnStatement>' +'\n')
        
        return None
    
    def compileIf(self):
        '''if(cond):
             s1
           else:
             s2
        '''
        self.ifcounter += 1
        iflabel1, iflabel2 = ('IF_FALSE'+str(self.ifcounter)),('IF_TRUE'+str(self.ifcounter))
        #self.f.write(self.ind + '<ifStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#if
        self.tn.advance()
        self.writetkn(False)#(
        self.tn.advance()
        self.compileExpression() #cond
        self.vmw.writeArithmetic('~',True) # denial
        self.writetkn(False)#)
        self.vmw.writeIf(iflabel1)# if-goto iflabel1
        self.tn.advance()
        self.writetkn(False)#{
        self.tn.advance()
        self.compileStatements() #S1
        self.writetkn(False)#}
        self.vmw.writeGoto(iflabel2) # goto iflabel2
        self.vmw.writeLabel(iflabel1) #label iflabel1
        if self.tn.tkns[self.tn.counter] == 'else':
            while(True):
                self.tn.advance()
                self.compileElse()
                if self.tn.currenttkn == '}':break
        self.vmw.writeLabel(iflabel2) # label iflabel2

        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</ifStatement>' +'\n')
        return None
    
    
    
    def compileElse(self):
        '''
        '''
        #self.f.write(self.ind + '<elseStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#else

        # self.writetkn(False)#)
        self.tn.advance()
        self.writetkn(False)#{
        self.tn.advance()
        self.compileStatements()
        self.writetkn(False)#}

        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</elseStatement>' +'\n')
        return None
    
    
    
    def compileTerm(self, SubroutineCall = False):
        '''Handles Expression in this function
        self.tn.currenttkn            indicates current token
        self.tn.tkns[self.tn.counter] indicates next token
        '''
        if not SubroutineCall :
            #self.f.write(self.ind + '<term>' +'\n')
            self.ind += '  '
            
        func = ''
        method = True
        while(True):
            
            if self.tn.tkns[self.tn.counter] == '(' and (self.tn.currenttkn not in ['~', '(', '-']):#subroutine
                self.writetkn(False)#subroutineName
                if func :
                    func += self.tn.currenttkn
                else:
                    func = self.classname + '.' + self.tn.currenttkn 
                    self.vmw.writePush('pointer',0)
                    
                self.tn.advance()
                self.writetkn(False)#(
                self.tn.advance()
                nArgs = self.compileExpressionList(method)
                
            elif self.tn.currenttkn == '(':#Expression in expression
                self.writetkn(False)#(
                self.tn.advance()
                self.compileExpression()
            
            elif self.tn.tkns[self.tn.counter] == '[':#Array
                self.writePushExp(self.tn.currenttkn) # push array base address
                self.writetkn(False)#ArrayName
                self.tn.advance()
                self.writetkn(False)#[
                self.tn.advance()
                self.compileExpression()
                self.vmw.writeArithmetic('+')
                self.writetkn(False)#]
                self.vmw.writePop('pointer',1)
                self.vmw.writePush('that',0)
                
            elif self.tn.tkns[self.tn.counter] == '.': # class.subroutine(
                self.writetkn(False)#objectinstance or classname
                func += self.tn.currenttkn
                if func not in dict(self.tbl.mtbl, **self.tbl.ctbl):#classname
                    method = False
                else: #object instance ->> instancename must be replaced with classname
                    self.writePushExp(self.tn.currenttkn)
                    func = self.tbl.typeOf(self.tn.currenttkn)
                self.tn.advance()
                self.writetkn(False)# .
                func += self.tn.currenttkn
                self.tn.advance()
                
            else:
                self.writePushExp(self.tn.currenttkn)
                break
            
        if func :self.vmw.writeCall(func, nArgs)
        self.writetkn(False)
        #self.tn.advance()
        if not SubroutineCall :
            self.ind = self.ind[:-2]
            #self.f.write(self.ind + '</term>' +'\n')
        return None
    
    
    
    def compileExpression(self):
        '''
        '''
        #self.f.write(self.ind + '<expression>' +'\n')
        self.ind += '  '
        op = None
        Unaryop = True
        while(True):
            
            if self.tn.currenttkn in [')',']',';',',']:break
            if self.tn.currenttkn in ['+','<','>','=', '-', '*', '/', '&','|','~']:
                self.writetkn(False)# 
                op = self.tn.currenttkn
                self.tn.advance()
            else:
                self.compileTerm()#
                self.tn.advance()
                Unaryop = False
                
        if op : self.vmw.writeArithmetic(op,Unaryop) 

        # self.writetkn(False)
        # self.tn.advance()
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</expression>' +'\n')
        return None
    
    def writePushExp(self, exp):
        ''' a one-stage approach
        
        #ex, ((y + size) < 254) goes below
        
            <term>
              <symbol> ( </symbol>
              <expression>
                <term>
                  <symbol> ( </symbol>
                  <expression>
                    <term>
                      <field1> y </field1>
                    </term>
                    <symbol> + </symbol>
                    <term>
                      <field2> size </field2>
                    </term>
                  </expression>
                  <symbol> ) </symbol>
                </term>
                <symbol> &lt; </symbol>
                <term>
                  <integerConstant> 254 </integerConstant>
                </term>
              </expression>
              <symbol> ) </symbol>
            </term>
        
        '''
        if exp.isdigit() :
            self.vmw.writePush('constant', exp)
        elif exp in [ 'true', 'false', 'null']:
            self.vmw.writePush('constant', 0)
            if exp == 'true':self.vmw.writeArithmetic('~',True)

            

        else:
            if exp in self.tbl.mtbl:
                self.vmw.writePush(self.tbl.mtbl[exp][1], self.tbl.mtbl[exp][2])
            else:
                if exp in self.tbl.ctbl:
                    self.vmw.writePush(self.tbl.ctbl[exp][1], self.tbl.ctbl[exp][2])
            
            


    
    def compileExpressionList(self,method):
        '''
        '''
        #self.f.write(self.ind + '<expressionList>' +'\n')
        self.ind += '  '
        numexp = 0
        if method :numexp += 1
        if not self.tn.currenttkn == ')':
            numexp += 1
            while(True):
                
                
                if self.tn.currenttkn == ')':break
                self.compileExpression()
                
                if self.tn.currenttkn == ',':
                    self.writetkn(False)#,
                    numexp += 1
                    self.tn.advance()
                else: 
                    if self.tn.currenttkn == ')':break
                    self.tn.advance()
            
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</expressionList>' +'\n')
        return numexp
    
    
    
    def compileStatements(self):
        '''
        '''
        #self.f.write(self.ind + '<Statements>' +'\n')
        self.ind += '  '
        while(True):
            if self.tn.currenttkn == '}':break
            self.writetkn(True)
            self.tn.advance()
        self.ind = self.ind[:-2]
        #self.f.write(self.ind + '</Statements>' +'\n')
        return None
    
    def close(self):
        '''Closes the output file.'''
        self.f.close()
    
if __name__ == "__main__":
    # execute only if run as a script
    #tgt = 'C:/Users/ikm1yh/Desktop/nand2tetris/projects/08/FunctionCalls/SimpleFunction/SimpleFunction.vm'
    #tgt = 'C:/Users/ikm1yh/Desktop/nand2tetris/projects/08/FunctionCalls/FibonacciElement'
    tgt = 'C:/Users/ikm1yh/Desktop/nand2tetris/projects/08/FunctionCalls/NestedCall'
    tgt = 'C:/Users/ikm1yh/Desktop/nand2tetris/projects/10/Square'
    print('tranlating...'+tgt)
#    asm = Assembler(sys.argv)
#    print(asm)



    print('Translation finished')