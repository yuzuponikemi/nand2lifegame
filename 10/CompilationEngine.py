# -*- coding: utf-8 -*-
"""
Created on Mon Mar 29 18:34:59 2021

CompilationEngine.py

Effects the actual compilation output. Gets its input from a JackTokenizer and emits
its parsed structure into an output file/stream. The output is generated by a series of compilexxx ( )
routines, one for every syntactic element xxx of the Jack grammar. The contract between these routines is
that each compilexxx ( ) routine should read the syntactic construct xxx from the input, advance ( ) the
tokenizer exactly beyond xxx, and output the parsing of xxx. Thus, compilexxx ( ) may only be called if
indeed xxx is the next syntactic element of the input.
In the first version of the compiler, described in chapter 10, this module emits a structured printout of
the code, wrapped in XML tags. In the final version of the compiler, described in chapter 11, this module
generates executable VM code. In both cases, the parsing logic and module API are exactly the same.


@author: IKM1YH
"""

class CompilationEngine:
    def __init__(self,tokenizerinstance, output):
        '''Opens the outputfile.asm and gets ready to write into it.'''
        self.tn = tokenizerinstance
        self.filename=output
        self.ind = ''
        self.f = open(self.filename, 'w')
    
    
    def cenginekey(self):
        #print(self.tn.tokenType())
        #self.typedic = {KEYWORD, SYMBOL, IDENTIFIER, INT_CONST, STRING_CONST}
        key = '//end with -->'+self.tn.currenttkn
        compiling = True
        if self.tn.currenttkn == 'class':self.compileclass()
        elif self.tn.currenttkn == 'var':self.compileVarDec()
        elif self.tn.currenttkn == 'do':self.compileDo()
        elif self.tn.currenttkn == 'let':self.compileLet()
        elif self.tn.currenttkn == 'while':self.compileWhile()
        elif self.tn.currenttkn == 'return':self.compileReturn()
        elif self.tn.currenttkn == 'if':self.compileIf()
        elif self.tn.currenttkn in ['method', 'constructor', 'function']:self.compileSubroutine()
        #if self.tn.currenttkn in ['int', 'char','boolean',classname]:self.compiletype()
        elif self.tn.currenttkn in ['field','static']:self.compileclassVarDec()
        #print(self.tn.keyWord())
        else : 
            key = self.tn.keyWord()
            compiling = False
        return key, compiling

        
    def cengine(self,mode):
        #print(self.tn.tokenType())
        #self.typedic = {KEYWORD, SYMBOL, IDENTIFIER, INT_CONST, STRING_CONST}
        if self.tn.tokenType() == 'KEYWORD':
            if mode:
                return self.cenginekey()
            else:
                return self.tn.keyWord(), False
        elif self.tn.tokenType() == 'SYMBOL':
            #self.ce.compilesymbol()
            return self.tn.symbol(), False
        elif self.tn.tokenType() == 'IDENTIFIER':
            #self.ce.compileidentifier()
            return self.tn.identifier(), False
        elif self.tn.tokenType() == 'INT_CONST':
            #self.ce.compileintVal()
            return self.tn.intVal(), False
        elif self.tn.tokenType() == 'STRING_CONST':
            #self.ce.compilestringVal()
            return self.tn.stringVal(), False
        else:
            return 'notype', False
        
    def writetkn(self,mode):
        #print(self.ind + self.cengine(mode))
        tagged, compiling = self.cengine(mode)
        if not compiling:
            self.f.write(self.ind + tagged)
        return None


    def compileclass(self):
        '''
        '''
        self.f.write(self.ind + '<class>' +'\n')
        self.ind += '  '
        self.writetkn(False)#write'class'
        self.tn.advance()
        while(True):
            if self.tn.currenttkn == '}':break            
            
            
            self.writetkn(True)
            self.tn.advance()
        self.writetkn(True)
        #self.tn.advance()
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</class>' +'\n')
        return None

    def compileclassVarDec(self):
        '''
        '''
        self.f.write(self.ind + '<classVarDec>' +'\n')
        self.ind += '  '
        self.writetkn(False)#write['field','static']
        while(True):
            if self.tn.currenttkn == ';':break
            self.tn.advance()
            self.writetkn(False)
            
        #self.tn.advance()
        
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</classVarDec>' +'\n')
        return None
    
    def compileSubroutine(self):
        '''
        '''
        self.f.write(self.ind + '<subroutineDec>' +'\n')
        self.ind += '  '
        #self.writetkn(False)
        while(True):
            if self.tn.currenttkn == '(':break
            self.writetkn(False)
            self.tn.advance()
        self.writetkn(False)
        self.tn.advance()
        
        self.compileParameterList()
        self.writetkn(False)
        self.tn.advance()
        self.compilesubroutineBody()
        
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</subroutineDec>' +'\n')
        return None
    
    def compileParameterList(self):
        '''
        '''
        self.f.write(self.ind + '<parameterList>' +'\n')
        self.ind += '  '
        #self.writetkn(False)
        while(True):
            if self.tn.currenttkn == ')':break
            self.writetkn(False)
            self.tn.advance()
        
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</parameterList>' +'\n')
        # self.writetkn(False)
        # self.tn.advance()
        return None
    
    def compilesubroutineBody(self):
        '''
        '''
        self.f.write(self.ind + '<subroutineBody>' +'\n')
        self.ind += '  '
        self.writetkn(False)
        self.tn.advance()
        while(True):
            
            if self.tn.currenttkn == 'var':
                self.compileVarDec()
            elif self.tn.currenttkn == '}':
                self.writetkn(False)
                break
            else:
                self.compileStatements()
    
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</subroutineBody>' +'\n')
        return None
    
    def compileVarDec(self):
        '''
        '''
        self.f.write(self.ind + '<varDec>' +'\n')
        self.ind += '  '
        self.writetkn(False)
        while(True):
            self.tn.advance()
            self.writetkn(False)
            if self.tn.currenttkn == ';':break
        self.tn.advance()
        
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</varDec>' +'\n')
        return None
    
    def compileDo(self):
        '''
        '''
        self.f.write(self.ind + '<doStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#do
        while(True):
            self.tn.advance()
            self.compileTerm(True)
            if self.tn.currenttkn == ';':break
        
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</doStatement>' +'\n')
        return None
    
    def compileLet(self):
        '''
        '''
        self.f.write(self.ind + '<letStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#let
        self.tn.advance()
        self.writetkn(False)#varName
        self.tn.advance()
        if self.tn.currenttkn == '[':
            self.writetkn(False)#[
            self.tn.advance()
            self.compileExpression()
            self.writetkn(False)#]
            self.tn.advance()
        self.writetkn(False)#=
        self.tn.advance()
        self.compileExpression()
        #self.tn.advance()
        self.writetkn(False)#;
        
        # while(True):
        #     self.tn.advance()
        #     self.writetkn(False)
        #     if self.tn.currenttkn == ';':break
        # self.tn.advance()
        
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</letStatement>' +'\n')
        return None
    
    def compileWhile(self):
        '''
        '''
        self.f.write(self.ind + '<whileStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#while
        self.tn.advance()
        self.writetkn(False)#(
        self.tn.advance()
        self.compileExpression()

        self.writetkn(False)#)
        self.tn.advance()
        self.writetkn(False)#{
        self.tn.advance()
        self.compileStatements()
        self.writetkn(False)#}
        
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</whileStatement>' +'\n')
        return None
    
    def compileReturn(self):
        '''
        '''
        self.f.write(self.ind + '<returnStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#return
        self.tn.advance()
        while(True):
            if self.tn.currenttkn == ';':break
            self.compileExpression()
            if self.tn.currenttkn == ';':break
            self.tn.advance()
        self.writetkn(False)#;
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</returnStatement>' +'\n')
        
        return None
    
    def compileIf(self):
        '''
        '''
        self.f.write(self.ind + '<ifStatement>' +'\n')
        self.ind += '  '
        self.writetkn(False)#if
        self.tn.advance()
        self.writetkn(False)#(
        self.tn.advance()
        self.compileExpression()

        self.writetkn(False)#)
        self.tn.advance()
        self.writetkn(False)#{
        self.tn.advance()
        self.compileStatements()
        self.writetkn(False)#}
        #self.tn.advance()

        
        if self.tn.tkns[self.tn.counter]  == 'else':
            while(True):
                self.tn.advance()
                self.writetkn(False) # else
                self.tn.advance()
                self.writetkn(False) # {
                self.tn.advance()
                self.compileStatements()
                if self.tn.currenttkn == '}':break

        
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</ifStatement>' +'\n')
        return None
    
    
    def compileTerm(self, SubroutineCall = False):
        '''
        '''
        if not SubroutineCall :
            self.f.write(self.ind + '<term>' +'\n')
            self.ind += '  '
        while(True):
            
            if self.tn.tkns[self.tn.counter] == '(' and self.tn.currenttkn != '(':
                self.writetkn(False)
                self.tn.advance()
                self.writetkn(False)#(
                self.tn.advance()
                self.compileExpressionList()
                
            elif self.tn.currenttkn == '(':
                self.writetkn(False)
                self.tn.advance()
                self.compileExpression()
            
            elif self.tn.tkns[self.tn.counter] == '[':
                self.writetkn(False)
                self.tn.advance()
                self.writetkn(False)#(
                self.tn.advance()
                self.compileExpression()
                
            elif self.tn.tkns[self.tn.counter] == '.':
                self.writetkn(False)#identifier
                self.tn.advance()
                self.writetkn(False)# .
                self.tn.advance()
                
            elif self.tn.currenttkn == '-': #????????
                self.writetkn(False)
                self.tn.advance()
                self.compileTeem()
                self.tn.advance()
                
            else:
                break
            
        self.writetkn(False)
        #self.tn.advance()
        if not SubroutineCall :
            self.ind = self.ind[:-2]
            self.f.write(self.ind + '</term>' +'\n')
        return None
    
    
    
    def compileExpression(self):
        '''
        '''
        self.f.write(self.ind + '<expression>' +'\n')
        self.ind += '  '
        place = 0
        while(True):
            
            if self.tn.currenttkn in [')',']',';',',']:break
            if self.tn.currenttkn in ['+','<','>','=', '-', '*', '/', '&','|'] and (place !=0):
                self.writetkn(False)# .
                self.tn.advance()
                place +=1
            else:
                self.compileTerm()
                self.tn.advance()
                place +=1
            
            
        # self.writetkn(False)
        # self.tn.advance()
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</expression>' +'\n')
        return None
    
    
    
    def compileExpressionList(self):
        '''
        '''
        self.f.write(self.ind + '<expressionList>' +'\n')
        self.ind += '  '
        while(True):
            
            
            if self.tn.currenttkn == ')':break
            self.compileExpression()
            if self.tn.currenttkn == ',':
                self.writetkn(False)#,
                self.tn.advance()
            else: 
                if self.tn.currenttkn == ')':break
                self.tn.advance()
        
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</expressionList>' +'\n')
        return None
    
    def compileStatements(self):
        '''
        '''
        self.f.write(self.ind + '<statements>' +'\n')
        self.ind += '  '
        while(True):
            if self.tn.currenttkn == '}':break
            self.writetkn(True)
            self.tn.advance()
        self.ind = self.ind[:-2]
        self.f.write(self.ind + '</statements>' +'\n')
        return None
    
    def close(self):
        '''Closes the output file.'''
        self.f.close()
    
if __name__ == "__main__":
    # execute only if run as a script
    tgt = 'C:/Users/ikm1yh/Desktop/nand2tetris/projects/08/FunctionCalls/NestedCall'
    tgt = 'C:/Users/ikm1yh/Desktop/nand2tetris/projects/10/Square'
    print('tranlating...'+tgt)
#    asm = Assembler(sys.argv)
#    print(asm)



    print('Translation finished')